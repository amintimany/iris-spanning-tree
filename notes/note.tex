\documentclass[]{scrartcl}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\usepackage{listings}
\usepackage{lstcoq}

\usepackage[dvipsnames]{xcolor}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}

\usepackage{todonotes}

\newtheorem{lemma}{Lemma}

\lstdefinelanguage[]{MyML}[]{ML}
{% general command to set parameter(s)
basicstyle=\small\ttfamily, % print whole listing small
keywordstyle=\color{blue}\bfseries,
morekeywords=[2]{CAS, true, false, null},
keywordstyle=[2]\bfseries,
identifierstyle=, % nothing happens
commentstyle=, % white comments
stringstyle=\ttfamily, % typewriter type for strings
showstringspaces=false, % no special string spaces
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=5pt,
escapeinside={(*@}{@*)}
}
\def\MyMLe{\lstinline[language=MyML, basicstyle=\small\ttfamily, mathescape=true]}

\newcommand{\defeq}{\overset{\Delta}{=}}
\newcommand{\path}{\mathit{path}}
\newcommand{\connected}{\mathit{connected}}
\newcommand{\nodes}{\mathit{nodes}}
\newcommand{\front}{\mathit{front}}
\newcommand{\maximal}{\mathit{maximal}}
\newcommand{\marked}{\mathit{marked}}
\newcommand{\inmem}{\mathit{in\text{-}memory}}
\newcommand{\localgr}{\mathit{local\text{-}graph}}
\newcommand{\globprot}{\mathit{global\text{-}protocol}}
\newcommand{\globmark}{\mathit{globally\text{-}marked}}
\newcommand{\Left}{\mathit{left}}
\newcommand{\Right}{\mathit{right}}
\newcommand{\tree}{\mathit{tree}}
\newcommand{\Null}{\mathit{null}}
\newcommand{\strictSG}{\subseteq_{\mathit{strict}}}

\newcommand{\dom}{\mathit{dom}}
\newcommand{\None}{\mathit{None}}
\newcommand{\Some}{\mathit{Some}}

\newcommand{\val}{\mathit{val}}
\newcommand{\loc}{\mathit{loc}}
\newcommand{\option}{\mathit{option}}
\newcommand{\Excl}{\mathit{Excl}}
\newcommand{\excl}{\mathit{excl}}
\newcommand{\Auth}{\mathit{Auth}}
\newcommand{\Frac}{\mathit{Frac}}
\newcommand{\finmap}{\overset{\mathit{fin}}{\rightharpoonup}}
\newcommand{\finset}{\mathit{gset}}

%change later to match other iris papers.
\newcommand{\own}{\mathfrak{own}}

\title{Notes on the verification of the concurrent spanning tree algorithm}

\begin{document}
\maketitle

\begin{abstract}
We give a short description of the verification of an
in-place concurrent algorithm for computing
a spanning tree of a graph described below.
\end{abstract}

\begin{figure}
\begin{lstlisting}[mathescape=true, language=MyML]
let try_mark x = CAS(x.mark, false, true)
let unmark_fst x = x.left := null
let unmark_snd x = x.right := null

let rec span x =
  if (x == null) then
    false (*@\label{x-null}@*)
  else
    if try_mark then (*@\label{the-cas}@*)
      let (l, r) =
        (span (x.left) || span (x.right)) in
      if ($\lnot$l) then unmark_fst;
      if ($\lnot$r) then unmark_snd;
      true (*@\label{return-true}@*)
    else
      false (*@\label{cas-fail}@*)
\end{lstlisting}
\caption{The pseudo-code of the spanning tree algorithm in ML style}
\label{fig:code}
\end{figure}

\section{The program}
The algorithm verified is depicted in Figure~\ref{fig:code}.
This algorithm does not compute \emph{the minimum
spanning tree} but rather \emph{a spanning tree}.
In particular, the shape of the computed spanning tree depends on the
scheduling of threads as threads race to mark nodes.
Intuitively, nodes marked by a thread (or its children) form the nodes of
the spanning tree computed by that thread.
Recursively, each thread that manages to mark a node, spawns two
threads to compute spanning trees for the children of that node. 
It then combines those spanning trees to compute a spanning tree with
the node that it has marked at the root.
A thread failing to mark a node will produce an empty
spanning tree.
It can on of the following two reasons.
The node the thread tried to mark does't exist
(the pointer \MyMLe{x} is \MyMLe{null}).
Or the node is already marked.
In both cases the parent thread sets its child to \MyMLe{null}.

In the following we first give short proof sketch why the algorithm
does what is claimed.
Later we discuss the proof in Iris which roughly speaking follows the
intuitive argument of Section~\ref{sect:int:reas}.
We finish by a short comparison with the other work by Sergey et al. \cite{Sergey:2015:MVF:2737924.2737964} that has formalized
the correctness of the same algorithm.

\section{Intuitive reasoning}\label{sect:int:reas}
\subsection{Basic definitions}
In this text we assume graphs are doubly branching.
Therefore, we refer to the children of a node as the left or right child (which may not exist for some nodes).
We write $x.\Left = \Null$ and $x.\Right = \Null$ whenever a node $x$ has no left or right child respectively.
Whenever not clear to which graph we are referring we use $g.x.\Left$ and $g.x.\Right$ to refer to the children of a node $x$ in a particular graph $g$.

We write $\path(p, g, x, y)$ to say that $p$ is a path in $g$ from $x$ to $y$.
Here a path $p$ is a sequence
$p = [d_1, \dots, d_n ]$ where $d_1,\dots, d_n \in \{\Left, \Right\}$.

We assume that there is always an empty path from a node to itself.
\[
x \in \nodes(g) \Rightarrow \path([], g, x, x)
\]
A graph is called connected from a node $x$ if for any node in the graph there is a path from $x$ to that node.
\[
\connected(g, x) \defeq \forall y \in \nodes(g).~ \exists p.~\path(p, g, x, y)
\]
where $\nodes(g)$ is the set of nodes of graph $g$.
\emph{The front} of a set of nodes $A$ in a graph is contained in
a set of nodes $B$ if $A \subseteq \nodes(g)$ and nodes immediately reachable
from nodes in $A$ are all in $B$. We write:
\[
\front(g, A, B) \defeq A \subseteq \nodes(g) \land
\{x \mid \exists y \in A.~x = y.\Left \lor x = y.\Right \} \subseteq B
\]
A graph is maximal if the set of it contains its the front of its nodes.
\[
\maximal(g) \defeq \front(g, \nodes(g), \nodes(g))
\]
A tree is a graph
\[
\tree(g, x) \defeq \forall y \in \nodes(g), \exists! p.~\path(p, g, x, y)
\]
A graph $g$ is strict subgraph of $g'$ written as $g \strictSG g'$
if the graph $g$ can be obtained from $g'$ by removing some nodes and children.
\[
\begin{array}{ll}
g \strictSG g' \defeq & \forall x \in \nodes(g).\\
& (g.x.\Left = \Null \lor g.x.\Left = g'.x.\Left)~\land \\
& (g.x.\Right = \Null \lor g.x.\Right = g'.x.\Right)
\end{array}
\]
A graph $g$ is a spanning tree of a graph $g'$ with root $x$ if
\[
x \in \nodes(g) \land g \strictSG g' \land \tree(g, x) \land \nodes(g) = \nodes(g')
\]
\begin{lemma}\label{lem:in_front_nodes}
\[
\forall A.~ \front(g, A) \subseteq A \Rightarrow A = \nodes(g)
\]
\end{lemma}
\subsection{Proof sketch}
Intuitively, the contract (in the Hoare triple style in separation logic) that we would want
to prove for \MyMLe{span} is as follows:
\begin{align*}
& \{\connected(g, x) \star \inmem(g) \star \marked(g) = \emptyset \star x \in \nodes(g)\} \\
& \text{\MyMLe{span}}~x \\
& \{\exists g'.~ \inmem(g') \star \nodes(g') = \nodes(g) \star \tree(g', x), g' \strictSG g \}
\end{align*}
It reads, given a graph $g$ such that the graph is in the memory,
where no node is marked (in the memory representation)
and $x$ (the argument) is a node of $g$ after the call
to \MyMLe{span $x$} there is another graph $g'$ which, in short,
is a spanning tree of $g$ with root $x$.

To prove that this Hoare triple indeed holds, we prove
another Hoare triple with weaker precondition
and stronger postcondition that is suitable for a proof
of the recursive calls.
In other words this contract (which we call the recursive contract for \MyMLe{span}) pertains to the intermediate
states which the program can be in due to the recursive call.

Since the recursive calls to \MyMLe{span} are executed
concurrently, the graph must be is shared among different threads.
We will therefore distinguish between the global knowledge
about the graph in memory and the (thread) local knowledge
which pertains to the part of the graph that is marked by the
current thread.
We use $\globmark$ to denote the set of the nodes that
are marked in the graph in memory. 
In order to specify and prove the correctness of \MyMLe{span} we will use
a protocol to enforce correct updates to the graph in memory.
Here we write $\globprot(g)$ to say that we have a protocol over the memory which intuitively says that
there is a graph $\mathcal{G}$ representing the part of the graph that is marked
(globally across all threads) such that $\mathcal{G} \strictSG g$,
the memory contains the graph $g$ when updated with
information in $\mathcal{G}$, i.e., $\inmem(\mathit{update}(g, \mathcal{G}))$, and that
the set of graph nodes marked in the memory is the set of nodes of $\mathcal{G}$, i.e., $\globmark = \nodes(\mathcal{G})$.
We use $\localgr(G)$ to say that $G$ is a graph representing
the (thread) local information, i.e., the part of the graph
(original graph which the protocol is stated about) that is marked by the current thread.
For this, we have the following holding:
\[
\localgr(G \uplus G') \dashv\vdash \localgr(G) \star \localgr(G')
\]
where $\uplus$ is disjoint union of graphs (nodes must be disjoint) and $\dashv\vdash$ is logical equivalence.
The recursive contract for \MyMLe{span} is as follows:
\begin{align*}
& \{\globprot(g) \star \localgr(\emptyset)
\star x \in \{\text{\MyMLe{null}}\} \cup \nodes(g)
\star \connected(g, x)
\} \\
& \text{\MyMLe{span}}~x \\
& \left\{
\begin{array}{l@{}l}
v. &\big( v = \text{\MyMLe{true}} \star x \neq \text{\MyMLe{null}}
\star \exists G.~\localgr(G) \star \tree(G, x) \star\\
& \hspace{1em} \front(g, \nodes(G), \globmark)
\star x \in \globmark \big)\\
& \lor\\
& \big(
v = \text{\MyMLe{false}}
\star (x = \text{\MyMLe{null}} \lor x \in \globmark)
\star \localgr(\emptyset)
\big)
\end{array}
\right\}
\end{align*}
\subsection{Establishing the global contract based on the local contract}
We will use the rule of consequence of Hoare logic.
We need to establish the precondition of the recursive contract
from the precondition of the global one.
Since we have just started the thread, we know that
$\localgr(\emptyset)$.
Apart from this, we also have to establish the global protocol $\globprot(g)$. To this end, we will take $\mathcal{G}$
to be the empty graph.

Next, we need to show that postcondition of the recursive contract
implies that of the global contract.
Since, from the precondition of the global contract we know that
$x \in \nodes(g)$ and also that nothing is marked initially we know that
the return value must be \MyMLe{true}.
In that case, we know that there is a graph $G$ such that
$\tree(G, x)$ and $\front(g, \nodes(G), \globmark)$.
We take $g'$ (in the postcondition of the global contract)
to be $G$. Since, the protocol states that
$\inmem(\mathit{update}(g, \mathcal{G})$ and
$\mathit{update}(g, \mathcal{G}) = \mathcal{G}$ whenever $\nodes(g) = \nodes(\mathcal{G})$,
we only need to prove the latter to show the postcondition of
the global contract.
Notice that we have as part of the post condition of the recursive contract $\front(g, \nodes(G), \globmark)$ and
from the contract we know that $\globmark = \nodes(\mathcal{G})$.
Hence, by Lemma~\ref{lem:in_front_nodes}, we have
$\nodes(g) = \nodes(\mathcal{G})$.

\subsection{Establishing the local contract}
Let's first consider the cases where
$x = \text{\MyMLe{null}}$ or \MyMLe{try_mark $x$} fails.
In both cases, we return \MyMLe{false} and the postconditions follows rather trivially. 
Otherwise, \MyMLe{try_mark $x$} has succeeded.
Notice that marking a node doesn't violate the protocol.
It merely extends $\mathcal{G}$ with node $x$.
In this case we have $x \in \globmark$ as well as
the local knowledge $\localgr(G)$ where $G$
is the graph consisting of only node $x$.
Notice that now the graph $G$ is not necessarily maximal as its left
and right children (should they exist) are not in $G$ itself.
We now run \MyMLe{span} concurrently on $x.\Left$ and $x.\Right$.
We need to establish the precondition for both children.
The protocol obviously holds, We also have that $G = G \uplus \emptyset \uplus \emptyset$ which implies
$\localgr(G) \dashv\vdash \localgr(G) \star \localgr(\emptyset) \star \localgr(\emptyset)$ the rest of the precondition follows trivially.
After these calls have finished, if they fail (due to the child being
\MyMLe{null} or it being already marked), we remove the child anyway.
Notice that remove children doesn't violate the protocol.
It merely updates $\mathcal{G}$ but preserves the $\strictSG$ condition.
Assuming that we get $\localgr(G_l)$ and $\localgr(G_r)$ back from
the recursive calls on the left and right child respectively,
we need to show the post condition for
$\localgr(G \uplus G_l \uplus G_r)$.
It follows rather easily from $\tree(x.\Left, G_l)$ and
$\tree(x.\Right, G_r)$ that $\tree(x, G \uplus G_l \uplus G_r)$.
Also, it follows from $\front(g, \nodes(G_l), \globmark)$,
$\front(g, \nodes(G_r), \globmark)$,
$x_l \in \globmark$ and $x_r \in \globmark$ that
$\front(g, \nodes(G \uplus G_l \uplus G_r), \globmark)$.

\section{Proof in Iris}
In Iris, we formalize graphs as finite maps from memory locations $\mathit{loc}$ to pairs of memory $\option~\loc$.
\begin{Coq}
Definition graph := gmap loc (option loc * option loc).
\end{Coq}

The main theorem proven in Irisi is \Coqe{wp_span} below:
\begin{Coq}
Lemma wp_span g markings (l : loc) :
    l $\in$ dom (gset _) g -> maximal g -> connected g l ->
    heap_ctx $\star$
    ([$\star$ map] l $\mapsto$ v $\in$ g,
       $\exists$ (m : loc), markings !! l = Some m $\star$
          l $\mapsto$ ($\#$m, children_to_val v) $\star$ m $\mapsto$ $\#$false) $\vdash$
    WP span (SOME $\#$l)
    {{ _, $\exists$ g',
            ([$\star$ map] l $\mapsto$ v $\in$ g',
              $\exists$ m : loc, markings !! l = Some m $\star$
                l $\mapsto$ ($\#$m, children_to_val v) $\star$ m $\mapsto$ $\#$true)
           $\star$ dom (gset _) g = dom (gset _) g'
           $\star$ $\scriptscriptstyle\blacksquare$ strict_subgraph g g' $\star$ $\scriptscriptstyle\blacksquare$ tree g' l }}.
\end{Coq}
Here $\star$ is the separating conjunction. The symbol $\scriptscriptstyle\blacksquare$ is notation for the modality that
embeds pure propositions (those of type \Coqe|Prop| in Coq) into
the separation logic language of Iris (the equality propositions are pure but they are treated specially in parsing so that this modality is applied without any syntactical cue).
The Iris proposition \Coqe|heap_ctx| is an invariant that relates the heap
assertions, e.g., the points-to assertion $\mapsto$, to the physical memory.
The notation \Coqe|[$\star$ map] x $
\mapsto$ v $\in$ g, P | for a finite map \Coqe|g| where \Coqe|x| and \Coqe|v| are free in \Coqe|P| is a Coq notation for $
\bigstar_{x \in A} P(x, g(x))$.
Similarly, the notation \Coqe|[$\star$ map] x $\in$ A, P | is the separating
conjunction over a finite set $A$.
The symbol $\#$ is a Coq notation. It is a part of the programming
language defined to write programs in Iris
\footnote{Iris is language agnostic and different languages can be formalized on top of it. Here we use the one that is defined as part of Iris itself.}.
It internalizes literals like locations and booleans from Coq types to the literal terms in the Iris language.

In this lemma \Coqe|markings| is the mapping that maps each node (location) to a location that contains the marking for that node.
It is necessary to add this mapping as a parameter throughout the
proof to make sure that no part of the program changes the
\emph{the address of} the marking for nodes.
This is crucial as the correctness of the program depends on the
race to mark the node and the fact that as soon as a thread sees
a node marked it stops assuming that another thread has processed or is
processing that node.

\subsection{The recursive contract for \Coqe|wp_span|}
The lemma \Coqe|wp_span| above states that given a location $l$ in a graph $g$
such that $g$ is maximal and connected from $l$, we have the the Hoare triple:
given that we own the graph $g$ in the heap, after running \Coqe|wp_span| we have
that there is a graph $g'$ such that we have $g'$ in the heap and $g$ is a strict sub graph of $g$, $g'$ has the same set of nodes as $g$ and $g'$ is a tree with root $l$.

This lemma in turn is proven using the consequence rule of Hoare logic 
by appealing to a recursive contract for the \Coqe|wp_span| which is
specified in the following lemma.

\begin{Coq}
Lemma rec_wp_span g markings k q (x : val) :
    maximal g ->
    (x = NONEV $\lor$ $\exists$ l : loc,
        x = SOMEV $\#$l $\land$ l $\in$ dom (gset _) g) ->
    (heap_ctx $\star$ graph_ctx $\kappa$ g markings $\star$ own_graph q $\emptyset$ $\star$ cinv_own $\kappa$ k)
      $\vdash$
      WP (span x)
      {{ v, ((v = $\#$ true $\star$
             ($\exists$ l : loc, x = SOMEV $\#$l $\star$
               ($\exists$ (G : Gmon) mr (tr : tree (Gmon_graph G) l),
                  own_graph q G $\star$ $\scriptscriptstyle\blacksquare$ (l $\in$ dom (gset _) G) $\star$
                  $\scriptscriptstyle\blacksquare$ maximal (Gmon_graph G) $\star$
                  $\scriptscriptstyle\blacksquare$ (front g (dom (gset _) G) mr) $\star$
                   ([$\star$ set] l $\in$ mr , is_marked l)) $\star$ is_marked l)) $\lor$
             (v = $\#$ false $\star$
              (x = NONEV $\lor$ ($\exists$ l : loc, x = SOMEV $\#$l $\star$ is_marked l))
               $\star$ own_graph q $\emptyset$))
            $\star$ cinv_own $\kappa$ k }}.
\end{Coq}

We will later explain \Coqe|graph_ctx $\kappa$ g markings| and
\Coqe|cinv_own $\kappa$ k| later. For now they don't matter in our
arguments.

This lemma basically states that given a value \Coqe|x| and maximal graph
\Coqe|g| such that \Coqe|x| is either \Coqe|NONEV| (read $\mathit{null}$) or a location in \Coqe|g|, we have the following Hoare triple:
given that we have a partial view of graph \Coqe|own_graph q $\emptyset$| that is we own fraction \Coqe|q| of the empty graph
(since we have not yet marked anything)\footnote {We will explain later why we need this fraction \Coqe|q|.}, after executing \Coqe|span|
we know that one of the following two cases holds.
The return value is true, in which case we own fraction \Coqe|q| of some
graph \Coqe|G|, \Coqe|own_graph q G|, (the spanning tree of the part that we have marked) that
is a tree, is maximal, we know its front is marked and that the node \Coqe|l| we started with is marked.
In the other case, the return value is false and we own the fraction \Coqe|q| of the empty graph (as we have failed to mark any nodes)
and we know that the node \Coqe|l| (if any) that we started with is marked.

Since in this algorithm the graph being worked on is shared among different threads as a whole, we need to enforce a protocol on how it
can be a accessed mutated by different threads.
This is why we talk about the partial view of the graph.
In other words, each thread only has solid knowledge about the shape of
the part of graph that it has marked itself (otherwise, this knowledge could be violated by actions of other threads).

\subsubsection{Monoids used}
Iris uses partial commutative monoids (here, monoid for short ) to represent its ghost states.
In Iris, one can compose monoids to build larger monoids.
The monoids are shared between different threads using the rule
\[
\own(a \cdot b) \dashv\vdash \own(a) \star \own(b)
\]
where $\own$ is the ownership of the ghost state, $\cdot$ is the monoid
operation and $\dashv\vdash$ is equivalence of Iris propositions.

In what follows we talk about local and global knowledge.
This refers to a specific monoid former called the authoritative
monoid former, $\Auth(A)$ for a monoid $A$.
We do not go into any detail of this monoid here.
Suffice it to say that elements of this monoid can express local and
global knowledge represented respectively with $\circ a$ and $\bullet a$
for an element $a \in A$.
The monoid operation is in such a way that composition of two
pieces of global knowledge is undefined (as there can be only one global knowledge) and composition of piece of global and a piece of local knowledge
is only defined when the global knowledge subsumes the local knowledge \footnote{Notice that given any partial commutative monoid, we define the subsumption order to be the extension order.}.
This means that we can only update the local information if we can also
update the global information.
The latter is only possible if we know that this will invalidate the local
knowledge of the other threads (if any).

In order to represent graphs in the ghost state (\Coqe|g| and \Coqe|G| in the lamma above) we define the following monoids.
\[
\mathit{Graph} \defeq \loc \finmap \option(\Excl(\val \times \val))
\]
where $\finmap$, $\option$ and $\Excl$ are monoid formers and $\val$ is the set of values of the language.
See the appendix for their definition.
Here, we just say that $\finmap$ is forms a partial map.
This definition is very close to our definition of graph.
The only difference is $\option$ and $\Excl$.
The $\option$ monoid former allows for partiality of knowledge,
we might not have any knowledge.
The exclusive monoid former $\Excl$ enforces exclusiveness of the
information.
If we know that a node has specific children, then other threads
can't have any knowledge about that node.
On other hand, knowing the children of a node allows us to mutate its
children. Notice that this is only possible if we have marked the node
ourselves.
These facts can be seen in the contracts for the \MyMLe{try_mark},
\MyMLe{unmark_fst} and \MyMLe{unmark_snd}.
\begin{Coq}
Lemma wp_try_mark g markings k q (x : loc) : x $\in$ dom (gset _) g ->
    heap_ctx $\star$ graph_ctx $\kappa$ g markings $\star$ own_graph q $\emptyset$
     $\star$ cinv_own $\kappa$ k
    $\vdash$ WP (try_mark $\#$x) {{ v,
         (v = $\#$true $\star$ ($\exists$ u, (g !! x) = Some u $\star$ own_graph q (x [$\mapsto$] u))
          $\star$ is_marked x $\star$ cinv_own $\kappa$ k)
           $\lor$ (v = $\#$false $\star$ own_graph q $\emptyset$ $\star$ is_marked x
              $\star$ cinv_own $\kappa$ k) }}.
\end{Coq}

\begin{Coq}
Lemma wp_unmark_fst g markings k q (x : loc) v w1 w2 :
    (g !! x) = Some v ->
    (heap_ctx $\star$ graph_ctx $\kappa$ g markings
     $\star$ own_graph q (x [$\mapsto$] (w1, w2)) $\star$ cinv_own $\kappa$ k) $\vdash$
      WP (unmark_fst $\#$x)
      {{ _, own_graph q (x [$\mapsto$] (None, w2)) $\star$ cinv_own $\kappa$ k }}.
\end{Coq}

\begin{Coq}
Lemma wp_unmark_snd g markings k q (x : loc) v w1 w2 :
    (g !! x) = Some v ->
    (heap_ctx $\star$ graph_ctx $\kappa$ g markings
    $\star$ own_graph q (x [$\mapsto$] (w1, w2)) $\star$ cinv_own $\kappa$ k) $\vdash$
      WP (unmark_snd $\#$x)
      {{ _, own_graph q (x [$\mapsto$] (w1, None)) $\star$ cinv_own $\kappa$ k }}.
\end{Coq}

The other monoid that is used here is the monoid for tracking markings.
The monoid that we use is just the monoid of finite sets of locations:
\[
\mathit{marking} \defeq \finset(\loc)
\]
In this monoid the monoid operation is union.
The most notable feature of this monoid is that for an element $A$, we have $A = A \cdot A$.
This means that the fact that a location is marked is free duplicatable.
Contrast this with the graph monoid where having local knowledge
about a location implies that that location is marked but this
local knowledge is exclusive in the sense that other threads can't
have any local knowledge about that location.

As we will explain later, the global knowledge of the graph monoid and
the global knowledge of the markings are linked in such a way that
they always agree on what is marked.
This means that once a location is marked, it can't effectively be unmarked as other threads might locally have the knowledge that
it is marked.
Notice that if we were to only use the graph monoid, since there
local knowledge is exclusive, we could always unmark a location
and forget the local knowledge that it is marked.
We could do this as removing the location from the global and
local knowledge can't violate any other threads local knowledge due to
its exclusive nature.

This duality between mutability of information and the ability to freely
duplicate the information is a general and intuitive pattern when working
in Iris.
Here we want to be able to update children of a node when we know
we have marked it ourselves and on the other hand have the knowledge
about nodes being marked duplicatable. Hence the use of two separate
monoids.
Notice in particular the postcondition for \Coqe|try_mark|. It in any case
guarantees that \Coqe|is_marked x| as it either manages to mark it or
sees it marked and can duplicate the fact that it is marked and
give us a token \Coqe|is_marked x| as an evidence.

\subsubsection{Fractions and invarinats}
The following is the definition of \Coqe|graph_ctx| and the invariant
used for defining it.
\begin{Coq}
Definition graph_inv (g : graph loc) (markings : gmap loc loc)
: iProp $\Sigma$ :=
    ($\exists$ (G : Gmon), own graph_name ($\bullet$ Some (1%Qp, G))
      $\star$ own graph_marking_name ($\bullet$ dom (gset _) G)
      $\star$ heap_owns (of_graph g G) markings $\star$
      $\scriptscriptstyle\blacksquare$ (strict_subgraph g (Gmon_graph G))
    )%I.
\end{Coq}

\begin{Coq}
Definition graph_ctx $\kappa$ g markings : iProp $\Sigma$ := 
  cinv graphN $\kappa$ (graph_inv g markings).
\end{Coq}

In Iris, ownership of ghost resources (e.g., \Coqe|graph_name| above) and invariants (e.g., \Coqe|graphN| above) are named.
The former is needed as we want the possibility to have different
instances of the same monoid structure while the latter is to avoid
openning an invariant multiple times which is not sound in general.

The invariant \Coqe|graph_inv| is parametrized by a graph (this is
intuitively the graph that we start with) and a markings map.
It basically says that there is a graph monoid \Coqe|G|,
such that the global knowledge about the graph (the parts that are
marked by different threads) is exactly represented by \Coqe|G| (with the whole fraction), the global knowledge about the markings is that all
locations in (domain of) \Coqe|G| are marked.
It furthermore says that the graph described by \Coqe|g| when updated
by \Coqe|G| is in the program heap and that \Coqe|G| is a strict subgraph
of \Coqe|g|.

Proof of the correctness of the program relies on this invariant which
in itself talks about physical ownership of the graph being worked on
in the heap.
On the other hand, the general contract \Coqe|wp_span| for \Coqe|span|, 
asserts physical ownership of the graph before and after the execution of
the program.
Therefore, not only do we have to establish the invaraint \Coqe|graph_inv| before using the recursive contract for span, \Coqe|rec_wp_span|
but also we have to get this physical ownership out of the invariant to
establish the post condition of \Coqe|wp_span| based on the postcondition
of \Coqe|rec_wp_span|.
However, as the name suggests, invariants are invariant, i.e., they can't
be changed.
The solution is to use what we call a cancelable invariant, written as
\Coqe|cinv| in \Coqe|graph_ctx|.
The idea here is that a cancelable invariant can only be opened if we
have a fraction of the token to open them. This is precisely what
\Coqe|cinv_own $\kappa$ k| is. It is a fraction \Coqe|k| of the token
to open a cancelable invariant with id $\kappa$.
Having the whole fraction of the token to open a cancelable invariant
allows one to invalidate the invariant so to speak by giving up the
token to open it; cancelling it in practice.

As we have seen throughout this section, the graph monoid is always
associated with a fraction.
Both the global and local knowledge about the graph include a fraction.
All contracts of the functions always preserve this fraction.
They may change the graph but they always give back some graph with
the same fraction as they started with.
To understand why we need this fraction let us take a closer look at the
postcondition of the \Coqe|rec_wp_span| forgetting about the fraction for
the moment.
In case the return result is true, we know that there is a graph \Coqe|G|
that we own, which is a tree, the node we start with is in there and
the front of the nodes of \Coqe|G| in the original graph \Coqe|g| are marked (part of the marking monoid).
Now, let's put this last statement together with the invariant that we have.
The invariant says that there is a graph let's say \Coqe|G'| that we own
globally and we know that the set of its nodes are those that are
in the global knowledge of the markings monoid.
Knowing that the local knowledge of the markings monoid is a subset of
the global knowledge of the markings graph we can conclude that:
\begin{Coq}
(front g (dom (gset _) G) (dom (gset _) G'))
\end{Coq}
In order to use Lemma~\ref{lem:in_front_nodes} and to conclude
\begin{Coq}
(dom (gset _) g) = (dom (gset _) G)
\end{Coq}
as we did in the intuitive reasoning, we have to show that \Coqe|G = G'|.
This in general is not something that we can prove and certainly not for
the graph monoid as we have defined.
The problem is that what we can conclude is that global knowledge
subsumes the local knowledge.
But that is not enough, it only gives us that 
\begin{Coq}
(dom (gset _) G) $\subseteq$ (dom (gset _) G')
\end{Coq}
The intuitive reason is that since we are doing modular proofs, we can't
be sure there still aren't other threads owning some other part of the
local knowledge.
However, adding a fraction to the graph monoid allows us to conclude
the desired.
The reason is that if we have the full fraction of the local knowledge
we can conclude that no other thread owns any local knowledge and
together with the subsumption we get from the authoritative monoid
we can prove that local and global knowledge should indeed coincide.

More precisely the graph monoid (\Coqe|Gmon| in Coq code above) is defined as
\[
\mathit{Gmon} \defeq \Frac \times \mathit{Graph}
\]
where $\Frac$ is the fraction monoid (elements: rational numbers in the interval $(0, 1]$; operation:  addition) and $\times$ is the product monoid former.

\section{Comparison}
The intuitive reasoning of the proof that we discussed above is inspired by that of \cite{Sergey:2015:MVF:2737924.2737964}.
The main difference in the implementation of these ideas comes from the
systems they are implemented in: Iris in our case and FCSL in theirs.
Here in Iris, we used monoids and invaraints to model ghost state and
enforce protocols.
In FCSL, they use the notion of a concurroid.

A concurroid is in practice a state-transition system (STS for short)
enforcing a rely-guarantee style protocol on threads.
In this case, the states of the STS they use are a partitioning of of the
heap corresponding to the graph into three different parts:
\textit{self}, \textit{joint} and \textit{other}.
Intuitively, \textit{self} is the part that the current thread has marked,
\textit{joint} is the part that is shared between threads (not yet marked)
and \textit{other} is the part that is marked by other threads.
there are then transitions on these states that correspond to marking
(which moves a node from \textit{joint} to \textit{self}) and removing
edges (to the left or right child) which removes the left/right child of a
node in \textit{self}.

Any assertion that is used in a proof of the correctness of the program
using a concurroid, e.g., those that appear in the pre-condition,
need to be shown to be stable.
That is, any such property, e.g., the fact that a node is marked, must be
shown to be stable under interference from other threads, i.e., with
respect to the concurroid transition.
In Iris, we don't have the concept of stability.
On the other hand, when we prove that some ghost resource can be
update to another we need to show that this doesn't violate other
threads' knwoledge of that ghost resource, e.g., marking is only possible
if the node is not already marked -- which we get from the fact that the \MyMLe|CAS| in \MyMLe|try_mark| succeeds.

A crucial part in proving the correctness of this program is the
assumption that when the top-level call to span happens there are
no other threads running \MyMLe|span|, i.e., it is indeed the top-level call.
In FCSL, this is enforced by an operation \textit{hide} which given a
concurroid and a program runs the program assuming there are no
other threads with access to the state managed by that concurroid.
In Iris, however, as the reasoning is completely modular, the graph
monoid that we have used is, as explained, paired with a fraction.
Since the recursive contract for \MyMLe|span| gives back in its
post-condition the same fraction of a graph that it was given and at
the top-level it is called with the full fraction we can conclude that
when the top-level call to \MyMLe|span| finishes there are indeed no
other threads running that have access to the grap.


\bibliographystyle{plain}
\bibliography{ref}

\appendix
\section{Monoids}
The monoid former $\finmap$ is constructs finite maps from a type to a monoid.
The composition operation $\cdot$ is defined as follows:
\[
(f \cdot g) (x) = \left\{
\begin{array}{ll}
f(x) & \text{if } x \in \dom(f)\setminus\dom(g)\\
g(x) & \text{if } x \in \dom(g)\setminus\dom(f)\\
f(x) \cdot g(x) & \text{if } x \in \dom(f)\cap\dom(g)\\
\bot & \text{otherwise}
\end{array}
\right.
\]
The monoid former of $\option(A)$ for a monoid $A$ has as elements 
$\None$ or $\Some(x)$ for $x \in A$ with:
\[
\begin{array}{ll}
\None \cdot \None = \None & \None \cdot \Some(x) = \Some(x) \\
\multicolumn{2}{c}{\Some(x) \cdot \Some(y) = \Some(x \cdot y)}
\end{array}
\]

The monoid former of $\option(A)$ for a monoid $A$ has as elements 
$\None$ or $\Some(x)$ for $x \in A$ with:
\[
\begin{array}{ll}
\None \cdot \None = \None & \None \cdot \Some(x) = \Some(x) \\
\multicolumn{2}{c}{\Some(x) \cdot \Some(y) = \Some(x \cdot y)}
\end{array}
\]

The monoid former of $\excl(A)$ for a \emph{type} $A$ has as elements 
$\excl(x)$ for $x \in A$ with:
\[
\begin{array}{ll}
a \cdot b = \bot
\end{array}
\]

The fraction monoid $\Frac$ has as elements rational numbers in the interval $(0, 1]$ and the operation is defined as:
\[
q \cdot q' = \left\{
\begin{array}{ll}
q + q' & \text{if } q + q' \le 1\\
\bot & \text{otherwise}
\end{array}
\right.
\]

The product monoid former $A \times B$ for monoids $A$ and $B$ has as elements pairs of elements of $A$ and $B$ and the operation is defined as:
\[
(a, b) \cdot (a', b') = (a \cdot a', b \cdot b')
\]

For the subsumption order (the extension order) for a moinoid $A$ we have that $a \preceq b$ defined as:
\[
a \preceq b \defeq a = b \lor \exists c.~b = a \cdot c
\]
Notice that the non-standard definition of extension order here as
there might not exists a $c$ such that $b = a \cdot c$.
The prime example here is the subsumption relation $1 \preceq 1$ in
$\Frac$.
This is exactly why we can derive:
\[
(1, a) \preceq (1, b) \Rightarrow a = b
\]

\end{document}