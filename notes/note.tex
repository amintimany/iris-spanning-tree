\documentclass[nocopyrightspace]{sigplanconf}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\usepackage{listings}
\usepackage{lstcoq}

\usepackage[dvipsnames]{xcolor}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.85]{beramono}

\newtheorem{lemma}{Lemma}

\lstdefinelanguage[]{MyML}[]{ML}
{% general command to set parameter(s)
basicstyle=\small\ttfamily, % print whole listing small
keywordstyle=\color{blue}\bfseries,
morekeywords=[2]{CAS, true, false, null},
keywordstyle=[2]\bfseries,
identifierstyle=, % nothing happens
commentstyle=, % white comments
stringstyle=\ttfamily, % typewriter type for strings
showstringspaces=false, % no special string spaces
numbers=left,
numberstyle=\tiny,
stepnumber=1,
numbersep=5pt,
escapeinside={(*@}{@*)}
}
\def\MyMLe{\lstinline[language=MyML, basicstyle=\small\ttfamily]}

\newcommand{\defeq}{\overset{\Delta}{=}}
\newcommand{\path}{\mathit{path}}
\newcommand{\connected}{\mathit{connected}}
\newcommand{\nodes}{\mathit{nodes}}
\newcommand{\front}{\mathit{front}}
\newcommand{\maximal}{\mathit{maximal}}
\newcommand{\Left}{\mathit{left}}
\newcommand{\Right}{\mathit{right}}
\newcommand{\istree}{\mathit{istree}}
\newcommand{\Null}{\mathit{null}}
\newcommand{\strictSG}{\subseteq_{\mathit{strict}}}

\newcommand{\loc}{\mathit{loc}}
\newcommand{\option}{\mathit{option}}

\title{Notes on the verification of the concurrent spanning tree algorithm}
\authorinfo{}{}{}

\begin{document}
\maketitle

\begin{abstract}
We give a short description of the verification of the concurrent algorithm for computing
a spanning tree of a graph described below.
\end{abstract}

\begin{figure}
\begin{lstlisting}[mathescape=true, language=MyML]
let rec span x =
  if (x == null) then
    false (*@\label{x-null}@*)
  else
    if (CAS(x.mark, false, true)) then (*@\label{the-cas}@*)
      let (l, r) =
        (span (x.left) || span (x.right)) in
      if ($\lnot$l) then x.left := null;
      if ($\lnot$r) then x.right := null;
      true (*@\label{return-true}@*)
    else
      false (*@\label{cas-fail}@*)
\end{lstlisting}
\caption{The pseudo-code of the spanning tree algorithm in ML style}
\label{fig:code}
\end{figure}

\section{The program and intuition}
The algorithm verified is depicted in Figure~\ref{fig:code}.
In this text we assume graphs are doubly branching.
Therefore, we refer to the children of a node as the left or right child (which may not exist for some nodes).
We write $x.\Left = \Null$ and $x.\Right = \Null$ whenever a node $x$ has no left or right child respectively.
Whenever not clear to which graph we are referring we use $g.x.\Left$ and $g.x.\Right$ to refer to the children of a node $x$ in a particular graph $g$.

We write $\path(p, g, x, y)$ to say that $p$ is a path in $g$ from $x$ to $y$.
Here a path $p$ is a sequence
$p = [d_1, \dots, d_n ]$ where $d_1,\dots, d_n \in \{\Left, \Right\}$.

We assume that there is always an empty path from a node to itself.
\[
x \in \nodes(g) \Rightarrow \path([], g, x, x)
\]
A graph is called connected from a node $x$ if for any node in the graph there is a path from $x$ to that node.
\[
\connected(g, x) \defeq \forall y \in \nodes(g).~ \exists p.~\path(p, g, x, y)
\]
where $\nodes(g)$ is the set of nodes of graph $g$.
The front of a set of nodes $A$ in a graph is the set of nodes immediately reachable from nodes in $A$.
\[
\front(g, A) \defeq \{x \mid \exists y \in \nodes(g).~x = y.\Left \lor x = y.\Right \}
\]
A graph is maximal if the set of its nodes is a subset of the front of its nodes.
\[
\maximal(g) \defeq \nodes(g) \subseteq \front(g, \nodes(g))
\]
A tree is a graph
\[
\istree(g, x) \defeq \forall y \in \nodes(g), \exists! p.~\path(p, g, x, y)
\]
A graph $g$ is strict subgraph of $g'$ written as $g \strictSG g'$
if the graph $g$ can be obtained from $g'$ by removing some nodes and children.
\[
\begin{array}{ll}
g \strictSG g' \defeq & \forall x \in \nodes(g).\\
& (g.x.\Left = \Null \lor g.x.\Left = g'.x.\Left)~\land \\
& (g.x.\Right = \Null \lor g.x.\Right = g'.x.\Right)
\end{array}
\]
A graph $g$ is a spanning tree of a graph $g'$ if
\[
g \strictSG g' \land \istree(g, x) \land \nodes(g) = \nodes(g')
\]
\begin{lemma}\label{lem:in_front_nodes}
\[
\forall A, \front(g, A) \subseteq A \Rightarrow A = \nodes(g)
\]
\end{lemma}
\subsection{The intuition}
Let's assume \MyMLe{x} is a node of the graph $g$ and the graph $g$ is connected from $x$.
Note that in such a case, any node \MyMLe{y} with a path from \MyMLe{x} to \MyMLe{y} is also a node of graph $g$.
Therefore, in the recursive calls we can assume that whenever we have a call \MyMLe{span y}, \MyMLe{y} is a node of graph $g$.

Intuitively, \MyMLe{span x} returns true if it has managed to mark \MyMLe{x}.
In that case, we know that there is a graph $g'$ such that
$g' \strictSG g$, $\istree(g', x)$, $\maximal(g')$, nodes of $g'$ are all marked and $\front(g, \nodes(g'))$ are marked (either by us through recursive calls or we have seen them marked through recursive calls).

If \MyMLe{span x} returns \MyMLe{false}, either \MyMLe{x} is \MyMLe{null} or we have seen it marked.

Let's confirm this intuition by going through the code.
The call \MyMLe{span x} returns \MyMLe{false} if \MyMLe{x} is \MyMLe{null}
(in line~\ref{x-null}) or if the \MyMLe{CAS} of line~\ref{the-cas} fails (in line~\ref{cas-fail}).
In the latter case, we know that \MyMLe{x.mark} is not \MyMLe{false} and there it
is \MyMLe{true} (i.e., \MyMLe{x} is marked).

Otherwise, if the \MyMLe{CAS} of line~\ref{the-cas} succeeds, the program returns \MyMLe{true} in line~\ref{return-true}.
In this case, we run \MyMLe{span} on the left and right child of \MyMLe{x} concurrently ad get result.
In case \MyMLe{span} returns \MyMLe{false} for any of the children, we remove it.
In what follows, we show that the desired properties hold.

First note that whenever we have a graph that consists of a node \MyMLe{x} and its children such that
 the children of \MyMLe{x} (if any) are maximal trees, the whole graph is a maximal tree.
Furthermore, since the children (if any) are strict subgraphs of the original graph
and for \MyMLe{x} we have only possibly removed children the whole graph
is a strict subgraph of the original graph.
Finally, note that front of the graph consisting of \MyMLe{x} and its children in the original graph is
the front of the children of \MyMLe{x} in the original graph and their fronts.
We know that these are all marked as guaranteed by the recursive calls on the children of \MyMLe{x} (they are either by the recursive calls or have been seen marked by the recursive calls).

At the top-level call to \MyMLe{span x}, we know that (as the pre-condition) \MyMLe{x} is not \MyMLe{null} and the graph we start with is not marked, it is maximal and it is it is connected from \MyMLe{x}.
Therefore, the call to \MyMLe{span x} can't return \MyMLe{false} as it would indicate \MyMLe{x} was \MyMLe{null} or \MyMLe{x} was marked which is contradiction.
Furthermore, we know that any marked node is marked (recursively) through this call.

Hence, at the top-level call to \MyMLe{span x} assuming \MyMLe{x} is a node of graph $g$, we know that there is a graph $g'$ such that
$g' \strictSG g$, $\istree(g', x)$, $\maximal(g')$, nodes of $g'$ are \emph{exactly those nodes that are marked} and $\front(g, \nodes(g'))$ are all marked.
Hence, we have $\front(g, \nodes(g')) \subseteq \nodes(g')$.
And by Lemma~\ref{lem:in_front_nodes} we have $\nodes(g) = \nodes(g')$.
Therefore, by definition of a spanning tree above we have $g'$ is a spanning tree
of $g$.

\section{Proof in Iris}
The main theorem proven in Irisi is \Coqe{wp_span} below:
\begin{Coq}
Lemma wp_span g markings (x : val) (l : loc) :
    l $\in$ dom (gset _) g -> maximal g -> connected g l ->
    heap_ctx $\star$
    ([$\star$ map] l $\mapsto$ v $\in$ g,
       $\exists$ (m : loc), markings !! l = Some m $\star$
          l $\mapsto$ ($\#$m, children_to_val v) $\star$ m $\mapsto$ $\#$false) $\vdash$
    WP span (SOME $\#$l)
    {{ _, $\exists$ g',
            ([$\star$ map] l $\mapsto$ v $\in$ g',
              $\exists$ m : loc, markings !! l = Some m $\star$
                l $\mapsto$ ($\#$m, children_to_val v) $\star$ m $\mapsto$ $\#$true)
           $\star$ dom (gset _) g = dom (gset _) g'
           $\star$ $\scriptscriptstyle\blacksquare$ strict_subgraph g g' $\star$ $\scriptscriptstyle\blacksquare$ tree g' l }}.
\end{Coq}

The proof of correctness of \MyMLe{span} in Iris follows the intuitive reasoning above.

In Iris, we formalize graphs as finite maps from memory locations $\mathit{loc}$ to pairs of memory $\option~\loc$.

\begin{Coq}
Definition graph := gmap loc (option loc * option loc).
\end{Coq}





\end{document}